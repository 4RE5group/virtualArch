<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emulator</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&amp;display=swap" data-tag="font">
</head>
<body>
    <div class="emulator-container">
        <div class="control-panel">
            <div class="binary-switches" onclick="viewUpdate()">
                <!-- Switches with labels -->
                <div class="switch"><span>ci</span><input type="checkbox"></div>
                <div class="switch"><span>-</span><input type="checkbox"></div>
                <div class="switch"><span>-</span><input type="checkbox"></div>
                <div class="switch"><span>*</span><input type="checkbox"></div>
                <div class="switch"><span>-</span><input type="checkbox"></div>
                <div class="switch"><span>u</span><input type="checkbox"></div>
                <div class="switch"><span>op1</span><input type="checkbox"></div>
                <div class="switch"><span>op0</span><input type="checkbox"></div>
                <div class="switch"><span>zx</span><input type="checkbox"></div>
                <div class="switch"><span>sw</span><input type="checkbox"></div>
                <div class="switch"><span>a</span><input type="checkbox"></div>
                <div class="switch"><span>d</span><input type="checkbox"></div>
                <div class="switch"><span>*a</span><input type="checkbox"></div>
                <div class="switch"><span>lt</span><input type="checkbox"></div>
                <div class="switch"><span>eq</span><input type="checkbox"></div>
                <div class="switch"><span>gt</span><input type="checkbox"></div>
            </div>
            <div class="output-display">
                <span>dec: <p id="decimal_result">0</p></span>
                <span>hex: <p id="hexadecimal_result">0x0</p></span>
                <button class="btn" onclick="asm_exec_opcode(result)">Execute</button>
            </div>
        </div>

        <div class="registers-panel">
            <div class="register"><span>a:</span> <p>0x0</p><span>(0)</span></div>
            <div class="register"><span>d:</span> <p>0x0</p><span>(0)</span></div>
            <div class="register"><span>*a:</span> <p>0x0</p><span>(0)</span></div>
        </div>

        <div class="code-editor-container">
            <div class="line-numbers"></div>
            <textarea class="code-editor" autocomplete="on" oninput="editRom()" name="asmcode" spellcheck="false"></textarea>
            <div class="pc-display">PC: <span id="pc_num">0</span></div>
            <div class="controls">
                <button class="btn" onclick="stepExec()">Step</button>
                <button class="btn" onclick="run()">Run</button>
                <button class="btn" onclick="stop()">Stop</button>
                <button class="btn" onclick="reset()">Reset</button>
                <label style="align-items: center; display: flex;">Speed<input id="runSpeedController" type="range" min="0" max="250" value="0"></label>
            </div>
        </div>

		<div class="terminal">
			<p>Live terminal</p>
			<canvas id="terminal_screen" width="640" height="480" onclick="document.getElementById('terminal_input').focus()"></canvas>
            <input id="terminal_input">
		</div>
        
    </div>
    <script src="./src/utils.js"></script>
    <script src="src/main.js"></script>
    <script src="./src/c_compiler.js"></script>
    <script src="./src/terminal.js"></script>
    
    <script>
        var result = 0;
        // add screen buffer mapping
		// placed at the end of the memory range
        addMemoryMapping("screen_buffer", "W", RAMSIZE-(SCREEN_WIDTH*SCREEN_HEIGHT), RAMSIZE-1, (index, type, value) => {
            if (registers.d >= 0 && registers.d < SCREEN_WIDTH*SCREEN_HEIGHT)
				screen_buffer[registers.d] = value;
        });

		// add character mapping
		addMemoryMapping("character_display", "W", RAMSIZE-(SCREEN_WIDTH*SCREEN_HEIGHT)-1, RAMSIZE-(SCREEN_WIDTH*SCREEN_HEIGHT), (index, type, value) => {
            // cursor pos is stored in memory at address RAMSIZE-(SCREEN_WIDTH*SCREEN_HEIGHT)-2
            let cursor = ram._memory[RAMSIZE-(SCREEN_WIDTH*SCREEN_HEIGHT)-2];
            let max_char_per_line = SCREEN_WIDTH / (FONT_SIZE);
            let x = Math.trunc(cursor % max_char_per_line);
            let y = Math.trunc(cursor / max_char_per_line);
            writeCharacter(x, y, String.fromCharCode(registers.d));
		});

        initScreen();
        displayScreen();


        document.getElementById("terminal_input").addEventListener("keydown", (e) => {
            let output_char = 0;
            console.log(e.code);
            if (e.code.startsWith("Key") || e.code.startsWith("Digit") || e.code.startsWith("Numpad"))
                output_char = e.code.replace("Key", "").replace("Digit", "").replace("Numpad", "").trim().charCodeAt(0);
            else 
            {
                switch (e.code)
                {
                    case 'Space':
                        output_char = " ".charCodeAt(0);
                        break;
                    case 'Backspace':
                        output_char = 8;
                        break;
                    case 'Enter':
                        output_char = "\n".charCodeAt(0);
                        break;
                    case 'Escape':
                        output_char = 27;
                        break;

                    case 'Period':
                        output_char = ".".charCodeAt(0);
                        break;
                    case 'Comma':
                        output_char = ",".charCodeAt(0);
                        break;
                    case 'Slash':
                        output_char = "/".charCodeAt(0);
                        break;
                    case 'Semicolon':
                        output_char = ";".charCodeAt(0);
                        break;
                    case 'Quote':
                        output_char = "'".charCodeAt(0);
                        break;
                    case 'Backslash':
                        output_char = "\\".charCodeAt(0);
                        break;
                }
            }
            ram._memory[RAMSIZE-(SCREEN_WIDTH*SCREEN_HEIGHT)-3] = output_char;
        });

        // to make lines follow code input
        document.querySelector(".code-editor").addEventListener("scroll", () => {
            document.querySelector(".line-numbers").scrollTop = document.querySelector(".code-editor").scrollTop;
        });

        document.querySelector(".line-numbers").style.height = (document.querySelector(".code-editor").clientHeight - 20)+"px";


        function viewUpdate()
        {
            result = 0;
            for (i = 0; i < 16; i++) {
                var elem = document.querySelector(".binary-switches").children.item(i).querySelector("input");
                if (elem.checked == true) {
                    result |= (1 << (15 - i));
                }
            }
            document.getElementById("decimal_result").innerText = result;
            document.getElementById("hexadecimal_result").innerText = "0x" + result.toString(16);

            // Helper function to format 16-bit unsigned hex
            function formatHex(value)
            {
                // Convert to 16-bit unsigned integer
                const unsignedValue = value & 0xffff;
                return "0x" + unsignedValue.toString(16).padStart(4, '0');
            }

            // a
            document.querySelector(".registers-panel").children.item(0).children.item(1).innerText = formatHex(registers.a);
            document.querySelector(".registers-panel").children.item(0).children.item(2).innerText = "(" + registers.a + ")";

            // d
            document.querySelector(".registers-panel").children.item(1).children.item(1).innerText = formatHex(registers.d);
            document.querySelector(".registers-panel").children.item(1).children.item(2).innerText = "(" + registers.d + ")";

            // *a
            document.querySelector(".registers-panel").children.item(2).children.item(1).innerText = formatHex(registers.a_ptr);
            document.querySelector(".registers-panel").children.item(2).children.item(2).innerText = "(" + registers.a_ptr + ")";
			displayScreen();
		}

        function editRom() 
        {
            // clear terminal
            console.clear();

            var lines = document.querySelector(".code-editor").value.split("\n");
            // handle define flags
            var definitions = new Map();
            
            // set global definitions
            definitions.set("WRITE", RAMSIZE-(SCREEN_WIDTH*SCREEN_HEIGHT)-1);
            definitions.set("CURSOR", RAMSIZE-(SCREEN_WIDTH*SCREEN_HEIGHT)-2);
            definitions.set("KEYPRESS", RAMSIZE-(SCREEN_WIDTH*SCREEN_HEIGHT)-3);
            definitions.set("SCREEN_BUFFER", RAMSIZE-(SCREEN_WIDTH*SCREEN_HEIGHT));
            
            let j = 0;
            let mem_pos = PROGRAM_TEXT_MEMSTART; // start offset of program TEXT memory
            lines.forEach(line => {
                line = line.trim();
                if (line.startsWith("#"))
                {
                    if (line.replace("#", "").trim().startsWith("DEFINE "))
                    {
                        line = line.split("DEFINE")[1].trim();
                        while (line.includes("  ")) // trim spaces between
                            line = line.replaceAll("  ", " ");
                        var elements = line.split(" ");
                        if (elements.length != 2)
                        {
                            console.error("error: invalid DEFINE preprocessor flag: '"+line+"'");
                            return;
                        }
                        // save definition
                        definitions.set(elements[0].trim(), elements[1].trim());
                    }
                }
                else if (line.trim().endsWith(":")) // labels
                {
                    line = line.split(":")[0].trim();
                    if (line == "TEXT") // text section
                    {
                        let k = j+1;
                        while (lines[k].startsWith(" ") || lines[k].startsWith("\t"))
                        {
                            let start_offset = -1;
                            lines[k] = lines[k].trim();
                            while(lines[k].includes("  "))
                                lines[k] = lines[k].replaceAll("  ", " ");
                            let elements = [
                                ...lines[k].split(" ").slice(0, 1), 
                                lines[k].split(" ").slice(1).join(' ').trim() // merge the rest into a single string
                            ];
                            // string type
                            if (elements[1].startsWith('"') && elements[1].endsWith('"'))
                            {
                                start_offset = mem_pos;
                                for(let _ = 1; _ < elements[1].length-1; _++)
                                {
                                    ram._memory[mem_pos++] = elements[1].charCodeAt(_);
                                }
                                ram._memory[mem_pos++] = 0;
                                console.log("registered a string at offset "+(mem_pos-elements[1].length+1));
                            } else if (isNumeric(elements[1])) {
                                start_offset = mem_pos;
                                ram._memory[mem_pos++] = Number(elements[1]);
                                console.log("registered a number at offset "+mem_pos);
                            } else {
                                console.error("error: invalid TEXT definition type: "+elements[1]);
                                return;
                            }
                            definitions.set(elements[0], start_offset.toString());
                            lines[k] = "#"+lines[k];
                            k++;
                        }
                    }
                    else
                    {
                        definitions.set(line, j.toString());
                    }
                    lines[j] = "#"+lines[j]; // comment line to skip it when running
                }
                j++;
            });
            // apply definitions
            definitions.forEach((value, key) => {
                // escape the key for use in a regex
                const escapedKey = key.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp(`(^|[^a-zA-Z0-9_-])(${escapedKey})(?=[^a-zA-Z0-9_-]|$)`, 'g');
                for(let i=0; i<lines.length; i++)
                {
                    // replace definition keyword in every lines
                    lines[i] = lines[i].replace(regex, `$1${value}`);
                }
            });
            console.log(lines.join("\n"));
            console.log(definitions);

            let i = 0;
            rom = [];
            lines.forEach(line => {
                // replace all char to its ascii value
                line = line.replace(/(['"])(?:\\.|.)\1/g, (match, quote) => { 
                    try
                    {
                        const content = match.slice(1, -1);
                        // parse the content to handle escape sequences
                        const char = JSON.parse(`"${content}"`);
                        return char.charCodeAt(0);
                    } catch (e) {
                        return match;
                    }
                 });
                // skip comments and new lines
                if (line.includes("#"))
                    line = line.split("#")[0];
                if (line.trim() != "" && !line.trim().endsWith(":")) { // skip empty lines and labels
                    let num = asm_to_opcode(line.trim());
                    if (num == -1) {
                        console.error(`error at line ${i+1}`);
                        reset();
                        return;
                    }
                    rom[i] = Number(num);
                }
                else
                    rom[i] == null;
                
                i++;
            });
            console.log(`successfully writted ${i} op codes to rom!`);
            reset();
        }

        function highlightCurrentLine(pc)
        {
            const lines = document.querySelector('.code-editor').value.split('\n');
            const lineNumbers = document.querySelector('.line-numbers');
            lineNumbers.innerHTML = lines.map((_, i) =>
                `<div${i+1 === pc ? ' class="highlight-line"' : ''}>${i+1}</div>`
            ).join('');
        }

        function stepExec()
        {
            registers.pc++;
            if (registers.pc <= 0)
            {
                alert("error: pc is outside range '"+registers.pc+"'");
                return;
            }
            if (registers.pc > rom.length) registers.pc = 1;
            highlightCurrentLine(registers.pc);
            document.getElementById("pc_num").innerText = registers.pc;
            if (rom[registers.pc - 1] != null) // skip comments/non code lines
                asm_exec_opcode(rom[registers.pc - 1]);
            viewUpdate();
        }

        function reset()
        {
			clearScreen();
            registers.pc = 0;
            document.getElementById("pc_num").innerText = registers.pc + 1;
            highlightCurrentLine(1);
        }

        var stopRun = false;
        var runSpeed = 250;

        function run()
        {
            stopRun = false;
            run_recur();
        }

        function stop()
        {
            stopRun = true;
        }

        function run_recur()
        {
            runSpeed = 250 - document.getElementById("runSpeedController").value;
            setTimeout(() => {
                stepExec();
                if (!stopRun)
                    run_recur();
            }, runSpeed);
        }
    </script>
</body>
</html>
